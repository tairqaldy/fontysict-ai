# Acceptance Testing and Unit Testing

# ğŸ” Testing From Both Sides

Unit testing validates your code, acceptance testing validates your understanding

**âš ï¸ The False Confidence Trap:** Your unit tests pass, your code looks clean, but when you demo to the client, they say "That's not what I wanted at all." Sound familiar? Unit tests validate that your code works as *you* intended, but acceptance tests validate that your code works as *they* intended. Both are essential, and both tell different stories about your software quality.

**ğŸ¯ Challenge Goal:** Experience the power of testing from both perspectives - technical validation through unit tests and user validation through acceptance tests. Learn why professional teams never ship software without both types of testing working in harmony.

## ğŸ­ The Testing Theater: Two Perspectives

**ğŸª The Developer's Performance (Unit Testing)**

As a developer, you're the playwright, director, and critic of your own code. Unit tests are your rehearsals - controlled, isolated, predictable. You test each "actor" (function/method) in isolation to ensure they perform their role correctly.

 **ğŸ¯ Unit Testing Focus:** * **Technical Correctness:** Does the code logic work as intended?

* **Edge Cases:** What happens with unexpected inputs?
* **Performance:** Are calculations and operations efficient?
* **Isolation:** Does each component work independently?

**ğŸ‘¥ The Audience's Review (Acceptance Testing)**

But even the best rehearsal can fail opening night. Acceptance testing is when real users (your "audience") experience your software in realistic scenarios. They don't care about your elegant code - they care about whether it solves their actual problems.

 **ğŸ¯ Acceptance Testing Focus:** * **User Experience:** Is the software intuitive and usable?

* **Business Value:** Does it actually solve the intended problem?
* **Workflow Integration:** How does it fit into real-world processes?
* **Requirement Validation:** Did we build what was actually needed?

## ğŸ› ï¸ Prerequisites & Resources

 **ğŸ“š Essential Preparation:** * **Research Assignment:** Do practical research on "Acceptance Testing" - understand the difference between acceptance testing and user testing

* **Unit Testing Tutorial:** Complete the [Microsoft Unit Testing Walkthrough**Links to an external site.**](https://learn.microsoft.com/en-us/visualstudio/test/walkthrough-creating-and-running-unit-tests-for-managed-code?view=vs-2022)
* **Your Individual Project:** Have a working feature that you can test with real users

**ğŸ¤” Reflection Questions:** Before starting, consider:* How do you currently validate that your code works correctly?

* When was the last time you thought your code was perfect but users disagreed?
* What's the difference between "working software" and "useful software"?

## ğŸ’¬ Discussion & Questions

Questions about testing strategies, user validation, or implementation approaches?

[ğŸ’¬ Join Testing Discussion](https://fhict.instructure.com/courses/15759/discussion_topics/94072)

## ğŸ¯ Three-Act Challenge

**ğŸ­ Act 1: The User's Reality (Acceptance Testing)**

Step into your user's shoes. This isn't about proving your code works - it's about discovering if your understanding of the problem was correct.

 **ğŸ¯ Your Mission:** 1. **Choose a Feature:** Select one specific requirement from your individual project

1. **Find a Real User:** Ask a teammate (not the developer) to test your feature
2. **Observe & Document:** Watch how they interact with your software - don't help or explain
3. **Discuss Results:** Together, determine if the requirement was implemented as intended
4. **Plan Improvements:** Note what needs to change for the next iteration

**âš ï¸ Critical Rule:** During testing, you are an  *observer* , not a  *helper* . If users need explanation, that's valuable feedback about your interface, not a training problem.

**ğŸ§ª Act 2: The Developer's Precision (Unit Testing)**

Now dive into the technical side. Write unit tests that prove your code logic is sound, covering both happy paths and edge cases.

 **ğŸ¯ Your Mission:** 1. **Identify Testable Logic:** Find methods in your individual project that contain business logic

1. **Write Unit Tests:** Create tests that validate the logic works correctly
2. **Test Edge Cases:** What happens with null values, empty data, or boundary conditions?
3. **Ensure Isolation:** Use mocks if needed to test components independently
4. **Document Behavior:** Your tests should clearly show what the code is supposed to do

**ğŸ’¡ Pro Tip:** If you've completed [the business logic testing workshop](https://fhict.instructure.com/courses/15759/pages/how-to-ensure-only-the-business-logic-is-unit-tested), apply those mocking techniques here for cleaner, more focused tests.

**ğŸ“ Act 3: The Reflection (Portfolio Integration)**

Connect your testing experiences to your learning journey. This is where technical skills meet professional reflection.

 **ğŸ¯ Your Mission:** 1. **Document the Process:** Take screenshots of your testing activities

1. **Explain Your Choices:** Why did you choose these specific tests?
2. **Justify Your Decisions:** What did you learn from each type of testing?
3. **Connect to Learning Outcomes:** How does this demonstrate your understanding of quality management?
4. **Plan Next Steps:** What will you do differently in your next iteration?

**ğŸ’¼ Portfolio Power:** This exercise demonstrates LO4 (Managing) and LO5 (Professional Standard) by showing how you use testing to ensure quality and communicate with stakeholders.

## ğŸ¯ Learning Outcome Connections

**LO4: Managing - Testing & Quality**

This challenge directly demonstrates your ability to:

* **Define and Execute Tests:** Both unit and acceptance testing methodologies
* **Improve Code Quality:** Use testing feedback to iteratively improve your software
* **Explain Testing Benefits:** Articulate how different testing approaches contribute to quality

**LO5: Professional Standard - Communication & Validation**

This challenge also supports:

* **Stakeholder Communication:** Working with users to validate requirements
* **Quality Reporting:** Documenting testing processes and results
* **Professional Reflection:** Analyzing and improving your development approach

## ğŸš€ Next Steps

**ğŸ“‹ Portfolio Check:** Before moving forward, ensure your portfolio is up to date with all your testing experiences, decisions, and reflections. This forms crucial evidence for your assessment.

*ğŸ­ Testing Truth: The best software isn't just technically correct - it's useful, usable, and valuable to real people. Unit tests prove you can code; acceptance tests prove you can solve problems. Master both, and you'll build software that actually matters.*

---

*Teacher resources: [Implementation guide](https://fhict.instructure.com/courses/15759/pages/teacher-guide-acceptance-testing-and-unit-testing-%257C-never-publish) (faculty access only)*

[](https://fhict.instructure.com/courses/15759/modules/items/1395137)

[](https://fhict.instructure.com/courses/15759/modules/items/1395140)
